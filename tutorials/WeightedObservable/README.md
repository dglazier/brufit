# Background subtraction then observable fit

//////////////////////////////////////////////////////////////////
In my model I have now generated a signal and background with differet mass sitributions. Also I have constructed an angle Phi which in the case of the signal has a polarisation depedent cos(2Phi) distribution. It is necessary to save the polarisation state as in integer PolState for use in the fit PDF, in general this should be -1,0,1, as well as the magnitude of polarisation as a seperate double. Note the polarisation is Egamma dependent and so must be handled event by event.

////////////////////////////////////////////////////////////////////
To generate data

   	    root 'Model2.C( "Data.root" )'
To Generate MC data for normalisation integral calculation

   	    root 'Model2.C( "MC.root",0 )'

//////////////////////////////////////////////////////////////////
### Background Subtraction
First I need to perform an sPlot fit to extract signal from background. This is exactly the same as for testSimple so heere I just copy the code to perform this in bins. This is file sPlotBins and you should be able to just run with root --hsfit sPlotBinsBins.C. This will perform 4 fits split in Eg and save the results and weights in outSignal

//////////////////////////////////////////////////////////////////////
### Fitting Observable

#### Making a new PDF class

Make a PDF class called PhiAsymmetry which depends on variable Phi and in addition the magitude of polarisation Pol and the polarisation state PolState, both of which are also recoreded in the tree. It has 2 fit parameters A and B which will be the cos and sin coefficeients respectively.

RooFit autogenerate custom pdf classes via the RooClassFactory. Here we extend this to pdfs inheriting from RooHSAbsEventsPDF - the class that handles simulated event trees for PDF integration and model event generation.
To make the skeleton code we use the THSSkeleton class :
   brufit
   root [0] .L RooFitSkeleton.cpp+
   root [1] RooFitSkeleton skel;
   root [2] skel.CreateRooFitEventsPDF("PhiAsymmetryPDF","Phi,Pol,CAT:PolState","A,B")

This creates a PDF that will fit variables in the input tree called Phi and Pol, with a RooCategory PolState (for asymmmetries) and with fit parameters called A and B. The user now has to define the fit function themselves. Open MyNewPDF.cxx; scrolll down to the evaluate() function (Nothing else should need edited) Replace the default return 1.0; with a suitable fit function :

     	     Double_t MyNewPDF::evaluate() const 
 	     	      { 
  		      return 1.0 + PolState*Pol*(A*TMath::Cos(2*TMath::DegToRad()*Phi)+B*TMath::Sin(2*TMath::DegToRad()*Phi));
 		      }
		      
Similar for evaluateMC() :

	    Double_t MyNewPDF::evaluateMC() const {
	    	     // ENTER IDENTICAL EXPRESSION TO evaluate() IN TERMS OF MC VARIABLE ARGUMENTS HERE
  		     Double_t mcPhi=(*vars)[fTreeEntry*fNvars+0];
  		     Double_t mcPol=(*vars)[fTreeEntry*fNvars+1];
  		     Int_t mcPolState=(*cats)[fTreeEntry*fNcats+0];
  		     return 1.0 + mcPolState*mcPol*(A*TMath::Cos(2*TMath::DegToRad()*mcPhi)+B*TMath::Sin(2*TMath::DegToRad()*mcPhi)); 
		     }



Note the lines Double_t mcPhi=fvecReal[fTreeEntry*fNvars+0]; are generated by the skelton code

Note the only difference between the functions is Phi->mcPhi and Pol->mcPol

That should be the PDF completed.

//////////////////////////////////////////////////////////////////////////


The form of the function is given in the Model1.C file which generated the events :
 TF1* fPhip=new TF1("phip","1+[2]*([0]*cos(2*TMath::DegToRad()*x)+[1]*sin(2*TMath::DegToRad()*x))",-180,180);



///////////////////////////////////////////////////////////////////

## First perform sPlot

   	 brufit sPlotBins.C

## Then observable fit

First you will need to make sure you are using the PhiAsymmetryPDF.cxx Look at FitObsBins.C for the line

      	 RF.SetUp().FactoryPDF("PhiAsymmetryPDF::SigAsym( Phi,Pol,PolState,A[0,-1,1],B[0,-1,1] )");

This is where you create your PDF, which is a function of Phi, Pol and PolState, while having fir parameters A and B

In the ROOT script FitObsBins.C

Note 0) Load the PDF with Loader::Compile("PhiAsymmetryPDF.cxx"); This is necessary for compiling on PROOF as well.

Note 1) we also include the weights from the sPlot fit in the line :

     	 RF.Data().LoadWeights("Signal","FULL/PATH/outsPlot/Tweights.root");

Note 2) we can use a MC integral for the PDF by including the MC.root data

     	 RF.LoadSimulated("MyModel","FULL/PATH/MC.root","SigAsym");

In this case the acceptance is flat so we can comment this line out and assume the normalisation integral is constant.

To run 
   	 brufit  FitObsBins.C


If you have made some bins/splits in the data e.g.


        RF.Bins().LoadBinVar("Eg",4,3,4);

The you can draw the fit parameters as a function of Eg by :

    	root --hsfit
    	.L GraphParameters.C
    	GraphParameters("outObs/","Eg");

The results graphs will be in the file outObs/ParGraphsEg.root